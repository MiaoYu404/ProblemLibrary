// Generated by ChatGPT

#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int n, m, q;
    cin >> n >> m >> q;
    vector<ll> a(n), b(m);
    ll A = 0, B = 0;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        A += a[i];
    }
    for (int j = 0; j < m; j++) {
        cin >> b[j];
        B += b[j];
    }

    // 构建 S_A 与 S_B
    // S_A = {A - a[i]}，S_B = {B - b[j]}
    unordered_set<ll> S_A; S_A.reserve(n*2); S_A.max_load_factor(0.7);
    for (int i = 0; i < n; i++) {
        S_A.insert(A - a[i]);
    }

    unordered_set<ll> S_B; S_B.reserve(m*2); S_B.max_load_factor(0.7);
    for (int j = 0; j < m; j++) {
        S_B.insert(B - b[j]);
    }

    while (q--) {
        ll x; cin >> x;
        // 枚举 x 的因子
        bool can = false;

        // 因子枚举
        // 我们只需考虑 |x| 的正因子，然后测试 (d, x/d)及(-d, -x/d) 等组合
        ll X = x < 0 ? -x : x;
        // 特殊情况：x = 0 的时候，因子处理逻辑类似
        // 不过|x|=0 会特别，需要单独处理:
        // x=0 的因子是任何数都可以使？不对，需要满足 X*Y=0 => X=0 或 Y=0
        // 检查 S_A 和 S_B 中是否有0元素。
        if (x == 0) {
            if (S_A.find(0) != S_A.end() && !S_B.empty()) {
                // 存在X=0，任意Y都行，但我们得保证Y存在
                // S_B一定非空，因为m>=1
                can = true;
            } 
            if (!can && S_B.find(0) != S_B.end() && !S_A.empty()) {
                can = true;
            }
            cout << (can ? "YES\n" : "NO\n");
            continue;
        }

        for (ll d = 1; d * d <= X && !can; d++) {
            if (X % d == 0) {
                ll e = x / d; // e = x/d
                // 当 d 为正因子时:
                ll d_pos = d;   // 正因子
                ll e_val = e;   // 相应的另一个因子

                // 检查 (d_pos, e_val)
                if (S_A.find(d_pos) != S_A.end() && S_B.find(e_val) != S_B.end()) {
                    can = true; break;
                }
                // 检查 (e_val, d_pos)
                if (S_A.find(e_val) != S_A.end() && S_B.find(d_pos) != S_B.end()) {
                    can = true; break;
                }

                // 考虑 ( -d_pos, -e_val )
                if (S_A.find(-d_pos) != S_A.end() && S_B.find(-e_val) != S_B.end()) {
                    can = true; break;
                }
                if (S_A.find(-e_val) != S_A.end() && S_B.find(-d_pos) != S_B.end()) {
                    can = true; break;
                }

                if (d * d != X) {
                    // X 还有另一个因子 X/d
                    ll d2 = X / d;
                    ll e2 = x / d2; 
                    // 同理再检查另一对因子 d2 和 e2
                    // (d2, e2)
                    if (S_A.find(d2) != S_A.end() && S_B.find(e2) != S_B.end()) {
                        can = true; break;
                    }
                    if (S_A.find(e2) != S_A.end() && S_B.find(d2) != S_B.end()) {
                        can = true; break;
                    }
                    // (-d2, -e2)
                    if (S_A.find(-d2) != S_A.end() && S_B.find(-e2) != S_B.end()) {
                        can = true; break;
                    }
                    if (S_A.find(-e2) != S_A.end() && S_B.find(-d2) != S_B.end()) {
                        can = true; break;
                    }
                }
            }
        }

        cout << (can ? "YES\n" : "NO\n");
    }

    return 0;
}
